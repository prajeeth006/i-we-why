using System.Collections.Concurrent;
using Frontend.Host.Features.ClientApp;
using Frontend.Vanilla.Core.Utils;
using Frontend.Vanilla.Features.WebAbstractions;
using Microsoft.AspNetCore.Http;
using Newtonsoft.Json;

namespace Frontend.Host.Features.Assets;

/// <summary>
/// Resolves file names from webpack manifest file generated by https://www.npmjs.com/package/webpack-manifest-plugin.
/// </summary>
public interface IWebpackManifestFileResolver
{
    /// <summary>
    /// Gets real file name from a webpack manifest.
    /// </summary>
    /// <param name="manifestPath">Relative path to the manifest file.</param>
    /// <param name="name">Name of webpack bundle to get actual file for.</param>
    /// <param name="cancellationToken"></param>
    Task<string> GetFileNameAsync(string manifestPath, string name, CancellationToken cancellationToken);

    /// <summary>
    /// Gets webpack manifest.
    /// </summary>
    /// <param name="manifestPath">Relative path to the manifest file.</param>
    /// <param name="cancellationToken"></param>
    Task<IReadOnlyDictionary<string, string>> GetFileAsync(string manifestPath, CancellationToken cancellationToken);

    /// <summary>
    /// Gets the content of a file from webpack manifest.
    /// </summary>
    /// <param name="manifestPath">Relative path to the manifest file.</param>
    /// <param name="name">Name of webpack bundle to get actual files for.</param>
    Task<string> GetFileContentAsync(string manifestPath, string name, CancellationToken cancellationToken);
}

internal sealed class WebpackManifestFileResolver(IHttpContextAccessor httpContextAccessor, SameSiteHttpClient sameSiteHttpClient, IClientAppService clientAppService)
    : IWebpackManifestFileResolver
{
    private const char CacheSeparator = '=';

    private async Task<string> GetCacheKeyAsync(string path, CancellationToken cancellationToken) =>
        $"{(clientAppService.Mode == ClientAppMode.FileServer ? await clientAppService.GetCurrentVersionAsync(cancellationToken) : clientAppService.Mode)}{CacheSeparator}{path}";

    private readonly ConcurrentDictionary<string, IReadOnlyDictionary<string, string>> manifestCache = new ();
    private readonly ConcurrentDictionary<string, string> fileCache = new ();

    public async Task<string> GetFileNameAsync(string manifestPath, string name, CancellationToken cancellationToken)
    {
        Guard.NotNull(manifestPath, nameof(manifestPath));
        Guard.NotNull(name, nameof(name));

        var manifest = await GetFileAsync(manifestPath, cancellationToken);

        return manifest.TryGetValue(name, out var resultName)
            ? resultName
            : throw new Exception(
                $"Record of name '{name}' not found in manifest '{clientAppService.Mode} {manifestPath}' (also available at URL '{manifestPath.TrimStart('~')}')."
                + " If the file is supposed to be there then webpack build failed or isn't configured correctly.");
    }

    public async Task<IReadOnlyDictionary<string, string>> GetFileAsync(string manifestPath, CancellationToken cancellationToken)
    {
        Guard.NotNull(manifestPath, nameof(manifestPath));

        var cacheKey = await GetCacheKeyAsync(manifestPath, cancellationToken);
        if (manifestCache.TryGetValue(cacheKey, out var cached)) return cached;

        var fresh = await GetFreshManifestAsync(manifestPath, cancellationToken);
        manifestCache.TryAdd(cacheKey, fresh);

        return fresh;
    }

    private async Task<IReadOnlyDictionary<string, string>> GetFreshManifestAsync(string path, CancellationToken cancellationToken)
    {
        try
        {
            var jsonStr = await GetFreshFileContentAsync(path, cancellationToken);
            var data = JsonConvert.DeserializeObject<Dictionary<string, string>>(jsonStr);

            if (data != null)
            {
                return data;
            }

            throw new Exception($"Unable to deserialize using {jsonStr}.");
        }
        catch (Exception ex)
        {
            var message = $"Error reading manifest from '{path}'.";

            throw new Exception(message, ex);
        }
    }

    public async Task<string> GetFileContentAsync(string manifestPath, string name, CancellationToken cancellationToken)
    {
        Guard.NotNull(manifestPath, nameof(manifestPath));
        Guard.NotNull(name, nameof(name));

        var file = await GetFileNameAsync(manifestPath, name, cancellationToken);

        if (fileCache.TryGetValue(file, out var cached)) return cached;

        var fresh = await GetFreshFileContentAsync(file, cancellationToken);
        fileCache.TryAdd(file, fresh);

        return fresh;
    }

    private async Task<string> GetFreshFileContentAsync(string path, CancellationToken cancellationToken)
    {
        try
        {
            var fullUrl = new Uri(httpContextAccessor.HttpContext!.Request.GetAppBaseUrl(), path);
            var response = await sameSiteHttpClient.GetStringAsync(fullUrl, cancellationToken);

            return response;
        }
        catch (Exception ex)
        {
            var message = $"Error reading contents of file '{path}'.";

            throw new Exception(message, ex);
        }
    }
}
